-- Transaction
DROP TABLE DEP02;

-- 테이블복사 (구조만 복사)
CREATE TABLE DEP02
AS
SELECT * FROM DEPARTMENTS WHERE 1 = 0;

-- 내용복사
INSERT INTO DEP02 SELECT * FROM DEPARTMENTS;

SELECT * FROM DEP02;

SAVEPOINT C1;

DELETE FROM DEP02 WHERE DEPARTMENT_ID = 90;

SELECT * FROM DEP02;

ROLLBACK TO C1;


-- EMPLOYEES 복사해서 EMP_COPY
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP_COPY;

-- VIEW 제거하기
DROP VIEW VIEW_EMP01;

-- VIEW 생성하기 (테이블생성 복사하기 똑같음)
CREATE VIEW VIEW_EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP_COPY WHERE DEPARTMENT_ID = 10;

-- SELECT
SELECT * FROM VIEW_EMP01;
SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID = 200;
-- VIEW 수정하기
UPDATE VIEW_EMP01 SET SALARY = 4500 WHERE EMPLOYEE_ID = 200;

-- DATA DICTIONARY(USER_TABLES, USER_CONSTRAINTS, USER_CONS_COLUMNS, USER_VIEWS, USER_INDEXES)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;

-- 가상뷰에 입력하기 (가상테이블에 컬럼 4개 입력, 원본 10개인데 그중에 NOT NULL 가상테이블에 포함되어 있지 않으면)
INSERT INTO VIEW_EMP01 VALUES(1000,'JDK',2000,50);
SELECT * FROM VIEW_EMP01;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP_COPY';

-- VIEW2 생성하기 (테이블생성 복사하기 똑같음)
CREATE VIEW VIEW_EMP02
AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMP_COPY WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP02;
INSERT INTO VIEW_EMP02 VALUES(1000,'MIN_SUNG','KWON','AAAAA@NAVER.COM',TO_DATE('2020/01/01', 'YYYY/MM/DD'),'IT_DEV');

COMMIT;
SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID = 1000;
DESC EMP_COPY;

-- VIEW3 생성하기
CREATE VIEW VIEW_EMP03
AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMP_COPY;

SELECT * FROM VIEW_EMP03 WHERE EMPLOYEE_ID = 2000;

INSERT INTO VIEW_EMP03 VALUES(2000,'MIN_SUNG','KWON','AAAAA@NAVER.COM',TO_DATE('2020/01/01', 'YYYY/MM/DD'),'IT_DEV');

SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID = 2000;

-- 가상뷰에서 삭제를 진행하기
DELETE FROM VIEW_EMP03 WHERE EMPLOYEE_ID = 2000;

-- 복합뷰 생성하기 (EMPLOYEES, DEPARTMENTS) 두개의 테이블에서 조인해서 새로운 가상테이블 만들기
CREATE OR REPLACE VIEW VIEW_EMP_DEP
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, E.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID DESC WITH READ ONLY;

SELECT * FROM VIEW_EMP_DEP;
SELECT DISTINCT DEPARTMENT_ID, DEPARTMENT_NAME FROM VIEW_EMP_DEP;
-- 부서명 IT 연봉 평균, 최고값, 최저값을 구해주세요
SELECT DEPARTMENT_NAME, MAX(SALARY), MIN(SALARY) FROM VIEW_EMP_DEP WHERE DEPARTMENT_NAME = 'IT' GROUP BY DEPARTMENT_NAME;

-- VIEW FORCE
CREATE OR REPLACE FORCE VIEW VIEW_FORCE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID FROM EMP20;

DESC VIEW_FORCE;

SELECT * FROM EMP20;

SELECT * FROM USER_VIEWS;

-- ROWNUM
SELECT * FROM EMPLOYEES;
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100
ORDER BY FIRST_NAME DESC;
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100;

-- ROWNUM 정렬하면 순서가 흐트러진것을 다시 순서적으로 보여주고 싶을때
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

CREATE OR REPLACE VIEW VIEW_HIREDATE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE WHERE ROWNUM = 4;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM
(SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC)
WHERE ROWNUM <= 4;
